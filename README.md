# Лабораторная работа: Реализация квантовых гейтов

## Цель

Реализовать базовые квантовые операции:
- Класс для представления кубита
- Гейты Паули (X, Y, Z)
- Двухкубитный гейт CNOT
- Визуализировать поведение кубита

---

## Теория

### Кубит

Кубит — это суперпозиция двух базисных состояний: |ψ⟩ = α|0⟩ + β|1⟩

Где:
- α и β — комплексные числа
- |α|² + |β|² = 1 — условие нормализации

Измерение кубита даёт:
- 0 с вероятностью |α|²
- 1 с вероятностью |β|²

### Квантовые гейты

Квантовые гейты — это унитарные матрицы. Применяются как: |ψ'⟩ = U |ψ⟩
#### ▪️ Гейты Паули

| Название | Матрица |
|----------|---------|
| Pauli-X  | `[[0, 1], [1, 0]]` |
| Pauli-Y  | `[[0, -i], [i, 0]]` |
| Pauli-Z  | `[[1, 0], [0, -1]]` |

#### ▪️ Гейт CNOT (2 кубита)

CNOT (Controlled-NOT) работает с двумя кубитами:

- первый — **контролирующий**

- второй — **целевой**

Если первый кубит равен |1⟩, второй инвертируется.

CNOT = | `[[1, 0, 0, 0],
[0, 1, 0, 0],
[0, 0, 0, 1],
[0, 0, 1, 0]]` |

---

## Реализация (описание кода)

### Класс `Qubit`

Моделирует состояние одного кубита в виде комплексного вектора: |ψ⟩ = α|0⟩ + β|1⟩.

Методы:

- `__init__(alpha, beta)` инициализация состояния
- `normalize()` нормализация состояния, чтобы |α|² + |β|² = 1
- `apply_gate` применяет 2×2 матрицу
- `measure` возвращает 0 или 1 с нужной вероятностью
- `__str__` красиво выводит состояние

### Гейты X, Y, Z

Реализованы как функции, возвращающие соответствующие матрицы NumPy.

### Класс `QubitPair`

Работает с парой кубитов. Состояние представляется как тензорное произведение: |ψ₁⟩ ⊗ |ψ₂⟩ = |ψ₁ψ₂⟩

Метод `apply_gate` применяет CNOT (матрицу 4×4) к этому состоянию.

---

## Визуализация

Для визуализации состояний используется библиотека **matplotlib**. Строится **гистограмма вероятностей** состояний |0⟩ и |1⟩ на каждом этапе:

```
q = Qubit(1, 0)  # состояние |0⟩
print("Начальное состояние:", q) # Начальное состояние: 1.00+0.00j|0⟩ + 0.00+0.00j|1⟩
visualize_qubit(q, "Нач. состояние |0⟩")

```

![image](https://github.com/user-attachments/assets/66fc7309-285f-4f50-8453-4a6f59891e41)


```
q.apply_gate(pauli_x())
print("После X-гейта:", q) # После X-гейта: 0.00+0.00j|0⟩ + 1.00+0.00j|1⟩
visualize_qubit(q, "После X-гейта")
```

![image](https://github.com/user-attachments/assets/5a3ba199-1590-4e4a-b7af-ef932e6e4e2f)


```
q.apply_gate(pauli_y())
print("После Y-гейта:", q) # После Y-гейта: 0.00-1.00j|0⟩ + 0.00+0.00j|1⟩
visualize_qubit(q, "После Y-гейта")
```

![image](https://github.com/user-attachments/assets/ff75d8e0-505f-45b2-8e1f-1f094f65d583)


```
q.apply_gate(pauli_z())
print("После Z-гейта:", q) # После Z-гейта: 0.00-1.00j|0⟩ + 0.00+0.00j|1⟩
visualize_qubit(q, "После Z-гейта")
```

![image](https://github.com/user-attachments/assets/252cb929-91c1-43f5-a682-955b4aeddfe0)

---

## Вывод 

- Однокубитные гейты (X, Y, Z) работают корректно: состояние изменяется согласно унитарному преобразованию.
- Гейт CNOT корректно выполняет условную инверсию второго кубита.
- Визуализация подтверждает изменение вероятностей состояния после каждой операции.
- Фазовые изменения не отображаются на гистограмме, но сохраняются в комплексной части амплитуд.



